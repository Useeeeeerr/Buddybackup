<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Discord Bot Data Manager</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background-color: #f0f2f5; color: #1c1e21; margin: 0; padding: 20px; display: flex; justify-content: center; align-items: flex-start; }
        .container { background-color: #fff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); padding: 20px; max-width: 600px; width: 100%; }
        h1, h2 { color: #5865F2; border-bottom: 1px solid #ddd; padding-bottom: 10px; }
        .input-group { margin-bottom: 15px; }
        label { display: block; font-weight: bold; margin-bottom: 5px; }
        input[type="text"], input[type="password"] { width: 95%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 16px; }
        button { background-color: #5865F2; color: #fff; border: none; padding: 12px 20px; border-radius: 4px; font-size: 16px; cursor: pointer; transition: background-color 0.3s; width: 100%; margin-top: 10px; }
        button:hover { background-color: #4752C4; }
        button:disabled { background-color: #a0a0a0; cursor: not-allowed; }
        #status { margin-top: 20px; padding: 15px; background-color: #f0f2f5; border: 1px solid #ddd; border-radius: 4px; white-space: pre-wrap; word-wrap: break-word; font-family: 'Courier New', Courier, monospace; max-height: 200px; overflow-y: auto; }
        .hidden { display: none; }
        a { color: #5865F2; }
    </style>
</head>
<body>

<div class="container">
    <h1>🤖 Discord Bot Data Manager</h1>

    <div id="auth-section">
        <h2>1. 인증 정보 입력</h2>
        <div class="input-group">
            <label for="railway-token">Railway API Token</label>
            <input type="password" id="railway-token" placeholder="API 토큰을 입력하세요">
            <small>토큰은 <a href="https://railway.app/account/tokens" target="_blank">여기</a>에서 생성할 수 있습니다.</small>
        </div>
        <div class="input-group">
            <label for="project-id">Project ID</label>
            <input type="text" id="project-id" placeholder="프로젝트 ID를 입력하세요">
        </div>
        <div class="input-group">
            <label for="service-id">Service ID</label>
            <input type="text" id="service-id" placeholder="서비스 ID를 입력하세요">
             <small>프로젝트/서비스 ID는 Railway URL에서 찾을 수 있습니다.<br> (.../project/<b>PROJECT_ID</b>/service/<b>SERVICE_ID</b>)</small>
        </div>
        <button id="save-auth">인증 정보 저장</button>
    </div>

    <div id="main-section" class="hidden">
        <h2>2. 데이터 관리</h2>
        <button id="backup-btn">데이터 백업 시작</button>
        
        <hr style="margin: 20px 0;">

        <h2>3. 데이터 복원</h2>
        <div class="input-group">
            <label for="backup-file">백업 파일 선택 (.tar.gz)</label>
            <input type="file" id="backup-file" accept=".tar.gz">
        </div>
        <button id="restore-btn" disabled>복원 시작</button>
    </div>

    <div id="status">상태 대기 중...</div>
</div>

<script>
    const railwayTokenInput = document.getElementById('railway-token');
    const projectIdInput = document.getElementById('project-id');
    const serviceIdInput = document.getElementById('service-id');
    const saveAuthBtn = document.getElementById('save-auth');
    const backupBtn = document.getElementById('backup-btn');
    const restoreBtn = document.getElementById('restore-btn');
    const backupFileInput = document.getElementById('backup-file');
    const statusDiv = document.getElementById('status');
    const authSection = document.getElementById('auth-section');
    const mainSection = document.getElementById('main-section');

    const RAILWAY_API_URL = 'https://backboard.railway.app/graphql/v2';
    // Netlify 프록시 주소는 상대 경로로 지정합니다.
    const OUR_PROXY_URL = '/.netlify/functions/proxy'; 

    // Railway API 호출 함수 (수정됨)
    async function callRailwayAPI(query, token) {
        try {
            const response = await fetch(OUR_PROXY_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    // 프록시(proxy.js)가 이해할 수 있는 형식으로 데이터를 보냅니다.
                    railway_url: RAILWAY_API_URL,
                    options: {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${token}`
                        },
                        body: JSON.stringify({ query })
                    }
                })
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`HTTP 오류! 상태: ${response.status}, 내용: ${errorText}`);
            }
            
            const result = await response.json();
            if (result.errors) { throw new Error(result.errors.map(e => e.message).join('\n')); }
            
            // 오류가 API 응답 내부에 있는 경우 처리
            if (result.data && result.data.serviceInstanceExec && result.data.serviceInstanceExec.stderr) {
                throw new Error(result.data.serviceInstanceExec.stderr);
            }

            return result.data;
        } catch (error) {
            updateStatus(`API 호출 실패: ${error.message}`);
            throw error; // 오류를 상위로 전파하여 catch 블록에서 처리하도록 함
        }
    }

    // 원격 명령어 실행 함수
    async function executeCommand(command, token, serviceId) {
        // 백슬래시와 따옴표를 이스케이프 처리하여 JSON 문자열 문제를 방지합니다.
        const escapedCommand = command.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
        const query = `
            mutation {
                serviceInstanceExec(serviceId: "${serviceId}", command: "${escapedCommand}") {
                    stdout
                    stderr
                }
            }`;
        const data = await callRailwayAPI(query, token);
        const result = data.serviceInstanceExec;
        // stdout이 비어있으면 stderr을 반환할 수 있도록 수정
        if (result.stderr && !result.stdout) { throw new Error(result.stderr); }
        return result.stdout;
    }

    // 서비스 재배포 함수
    async function redeployService(token, serviceId) {
        const query = `
            mutation {
                serviceRedeploy(serviceId: "${serviceId}", input: {}) {
                    id
                }
            }`;
        return await callRailwayAPI(query, token);
    }
    
    function updateStatus(message) {
        console.log(message);
        statusDiv.textContent = message;
    }

    function loadAuthInfo() {
        const token = localStorage.getItem('railwayToken');
        const projectId = localStorage.getItem('railwayProjectId');
        const serviceId = localStorage.getItem('railwayServiceId');
        if (token && projectId && serviceId) {
            railwayTokenInput.value = token;
            projectIdInput.value = projectId;
            serviceIdInput.value = serviceId;
            authSection.classList.add('hidden');
            mainSection.classList.remove('hidden');
            updateStatus('인증 정보가 로드되었습니다. 백업 또는 복원을 시작하세요.');
        }
    }

    saveAuthBtn.addEventListener('click', () => {
        const token = railwayTokenInput.value.trim();
        const projectId = projectIdInput.value.trim();
        const serviceId = serviceIdInput.value.trim();
        if (token && projectId && serviceId) {
            localStorage.setItem('railwayToken', token);
            localStorage.setItem('railwayProjectId', projectId);
            localStorage.setItem('railwayServiceId', serviceId);
            authSection.classList.add('hidden');
            mainSection.classList.remove('hidden');
            updateStatus('인증 정보가 저장되었습니다. 백업 또는 복원을 시작하세요.');
        } else {
            alert('모든 필드를 입력해주세요.');
        }
    });

    backupFileInput.addEventListener('change', () => {
        restoreBtn.disabled = !backupFileInput.files.length > 0;
    });

    backupBtn.addEventListener('click', async () => {
        if (!confirm('데이터 백업을 시작하시겠습니까?')) return;
        backupBtn.disabled = true;
        restoreBtn.disabled = true;

        try {
            const token = localStorage.getItem('railwayToken');
            const serviceId = localStorage.getItem('railwayServiceId');
            
            updateStatus('1/3: 서버에서 bot_data 폴더를 압축 중입니다...');
            await executeCommand('tar -czf backup.tar.gz bot_data', token, serviceId);
            
            updateStatus('2/3: 다운로드 링크를 생성 중입니다...');
            // transfer.sh는 가끔 불안정하므로 대체 서비스를 사용하거나 stderr를 확인하는 것이 좋음
            const downloadUrl = await executeCommand('curl --upload-file ./backup.tar.gz https://transfer.sh/backup.tar.gz', token, serviceId);
            
            if (!downloadUrl || !downloadUrl.startsWith('http')) {
                throw new Error('다운로드 URL 생성에 실패했습니다. (transfer.sh 서비스 문제일 수 있습니다)');
            }

            updateStatus(`3/3: 백업 완료!\n아래 링크를 클릭하여 파일을 다운로드하세요:\n\n${downloadUrl}`);
            const link = document.createElement('a');
            link.href = downloadUrl;
            link.target = '_blank';
            link.textContent = downloadUrl;
            statusDiv.appendChild(document.createElement('br'));
            statusDiv.appendChild(link);

        } catch (error) {
            updateStatus(`백업 실패: ${error.message}`);
        } finally {
            backupBtn.disabled = false;
        }
    });

    restoreBtn.addEventListener('click', async () => {
        if (!confirm('데이터 복원을 시작하시겠습니까? 현재 서버의 데이터는 덮어씌워집니다.')) return;
        backupBtn.disabled = true;
        restoreBtn.disabled = true;
        
        try {
            const token = localStorage.getItem('railwayToken');
            const serviceId = localStorage.getItem('railwayServiceId');
            const file = backupFileInput.files[0];

            updateStatus('1/5: 백업 파일을 업로드하여 링크를 생성 중입니다...');
            
            const uploadResponse = await fetch('https://transfer.sh', {
                method: 'PUT',
                body: file,
                headers: { 'Content-Type': 'application/x-gzip' }
            });
            const uploadUrl = await uploadResponse.text();
            
            if (!uploadUrl.startsWith('http')) {
                throw new Error('백업 파일 업로드에 실패했습니다. (transfer.sh 서비스 문제일 수 있습니다)');
            }
            updateStatus(`2/5: 업로드 완료. URL: ${uploadUrl}`);

            updateStatus('3/5: 서버에서 백업 파일을 다운로드 중입니다...');
            await executeCommand(`curl -o backup.tar.gz ${uploadUrl}`, token, serviceId);

            updateStatus('4/5: 서버에서 데이터 압축을 푸는 중입니다...');
            try {
                await executeCommand('tar -xzf backup.tar.gz -C /data/', token, serviceId);
                updateStatus('볼륨에 데이터를 복원했습니다.');
            } catch (e) {
                await executeCommand('tar -xzf backup.tar.gz', token, serviceId);
                updateStatus('기본 위치에 데이터를 복원했습니다. (볼륨 미사용)');
            }

            updateStatus('5/5: 봇 서비스를 재시작하여 변경사항을 적용합니다...');
            await redeployService(token, serviceId);

            updateStatus('복원 완료! 서비스가 재시작될 때까지 몇 분 정도 기다려주세요.');
            
        } catch (error) {
            updateStatus(`복원 실패: ${error.message}`);
        } finally {
            backupBtn.disabled = false;
            restoreBtn.disabled = false;
        }
    });
    
    loadAuthInfo();
</script>

</body>
</html>